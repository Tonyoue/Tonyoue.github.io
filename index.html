<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>桐悠的读书笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="桐悠的读书笔记">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="桐悠的读书笔记">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="桐悠的读书笔记">
  
    <link rel="alternate" href="/atom.xml" title="桐悠的读书笔记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">桐悠的读书笔记</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">无限期咕咕咕~~~</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-从零到一自己开发一个网站需要用到多少知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/24/从零到一自己开发一个网站需要用到多少知识/" class="article-date">
  <time datetime="2017-11-24T07:25:10.000Z" itemprop="datePublished">2017-11-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/24/从零到一自己开发一个网站需要用到多少知识/">从零到一自己开发一个网站需要用到多少知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>现在主流的两种模式是C/S模式和B/S模式，今天先聊聊B/S模式开发需要的技术</p>
<p>首先，什么是B/S模式？B指的就是Browser，web浏览器，而s指的就是server，服务端</p>
<p>将整个网站通过这个模式其实就划分成了两大部分，用户所浏览的主页page部分，进行响应用户的server部分，首先说说page部分，page部分其实就是我们所说的前端，前端是一个大而且杂的方向，最基础的三个包括html、css、JavaScript，而基于js的又产生了一个叫做jQuery的，以及一个前端人员必须会但是又比较难的ajax，除了这些基本的东西之外，其实常听说的还有node.js，angularJS等等之类的，但是这里并不是很想把他们归在一起，因为就node.js来说，其实这是用来进行数据持久化的东西，而和用户的操作界面并没有关系，所以并没有放在一起</p>
<p>接下来先讲上述的三种东西：HTML、css、JavaScript。我们都知道一个网站的网页要让人浏览，最重要的一点是有清楚的逻辑结构，而负责完成这个逻辑结构的东西，就是html，然后html能实现的其实就是简单的布局，但是我们既然想设计网站，当然就要让网站变得漂亮一点，比如标题的字体更大，正文的字体小一点等等，而负责实现这些的，就是css，再者，html的中文叫做超文本标记语言，简单来说还是文本，那么当我们需要进行一些操作，比如当用户点击的时候出发一些事件的时候，我们就做出响应 ，这时候我们应该怎么做呢，这时候就需要使用到js了，而jQuery又是什么呢？jQuery是一个基于JavaScript的相似的脚本，在JavaScript的基础上进行的一定的封装，简单说就是简化了，更容易使用了，这里需要注意，js可以实现jQuery的一切功能，但是jQuery并不能实现js的一些功能。到此为止呢，一个网站的页面部分其实已经完成的差不多了，但是对于某些网站来说，并不像没有用户点击之后就刷新整个页面，这样用户体验就会变得很差，而ajax就算是用来实现在页面的局部进行刷新，而不刷新整个页面的技术，至此，纯page部分差不多说完了，其实，除此之外，向bootstrip也是用来优化用户体验，进行界面设计的，就不多加介绍，总之，前端的技术无穷无尽。</p>
<p>接着说下一个技术，后台部分，就是server端，首先，server端必须会的，自然就是服务器的知识了，那么服务器方面有啥需要了解的呢？首先是有一个服务器，现在技术的提升，针对不同的功能可以有不同的服务器，比如较老的Apache公司的lamp和wamp服务器，就是纯web端的服务器，除此之外，最近几年开始流行的nginx服务器，用来作为负载均衡的，或者是Hadoop生态圈的zookeeper，用来进行大数据处理的，再或者，更老年的tomcat服务器，用来实现jsp纯页面服务的，等等，但是，无论是哪一种服务器，都几乎是不能离开Linux的，除了wamp，所以，想要构建一个网站，就需要熟悉Linux的基本操作，而Linux的操作同样也是无穷无尽的，除了最基础的操作，服务器的排错都是必须会的</p>
<p>最后说如何实现两端之间的数据交互吧，当前可以实现的语言有很多，首先是php，jsp，以及前面所说的node.js，然后是java的j2ee版，其中j2ee需要会的部分是三大框架，spring，srtuct，hibernate，而前几年热门的springMVc则是在数据持久化上进行了改进，具体请自行百度，最后说说Python，Python不是不适合做网站开发，而是现在使用Python进行网站开发的公司偏少，而Python最优秀的地方，在于大数据处理，深度学习，实现CNN，RNN，GAN等等，简单来说，Python用来做网站开发，可以 使用的框架目前主流的有两个，一个 是完全在Linux实现的tornado，一个是Windows也可以使用的django。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/24/从零到一自己开发一个网站需要用到多少知识/" data-id="cjadl2o1m00023yjhp17oj65e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库索引树的原理-B树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/02/数据库索引树的原理-B树/" class="article-date">
  <time datetime="2017-11-02T05:20:03.000Z" itemprop="datePublished">2017-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/02/数据库索引树的原理-B树/">数据库索引树的原理_B树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在数据库索引的存储中，存储的方式一般是采用树形结构存储的方式，为的就是在查询的时候可以保持较高的效率，同时也可以让数据保持有序，但是有一个问题，就是索引并没有采用二叉查找树而是采用的B树的方式，这又是为什么呢？我们都知道二叉查找树的时间复杂度是O（logN）已经达到了足够高的性能了，但是我们仍不采用这种方式进行索引，最大的原因是我们在设计的时候，除了考虑到时间复杂度这一关键因素之外，我们还需要考虑到另外一个关键因素，就是空间复杂度，简单来说，当我们查找的数据大小是几十g的情况下，将所有的数据加载到内存中是不现实的事情的，因为这样首先内存不足，其次磁盘IO的开销也会非常大，我们所能做的就只是逐一加载磁盘页，磁盘页对应的索引树的节点，在最坏的情况下，需要进行的次数就是索引树的高度，而我们为了减少磁盘IO开销，就需要吧原本瘦瘦高高的树变成矮胖的结构，以此来减少磁盘IO次数。</p>
<p>未完待续</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/02/数据库索引树的原理-B树/" data-id="cjadl2o1x00033yjha1sbvuns" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-为什么需要通过做项目来提高代码的水平" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/17/为什么需要通过做项目来提高代码的水平/" class="article-date">
  <time datetime="2017-10-17T03:34:43.000Z" itemprop="datePublished">2017-10-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/17/为什么需要通过做项目来提高代码的水平/">为什么需要通过做项目来提高代码的水平</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>有这么一句话，就是说任何脱离了实际的理论都是在耍流氓，怎么说呢，作为一个工科生，并且是一个计算机专业的学生，很多知识如果不结合到实际之中，那么永远都是不会提高的。举一个最简单的例子：有一个长字符串，这个字符串中包含了很多的单词，单词之间用空格隔开，那么，想要求出最后一个单词的长度，应该使用什么方法？最常见的一个答案就是倒叙，然后正则取出最后一个单词，但是，在这个过程中，是否有考虑过如果这个长字符串的长度大到难以想象，比如说100g的话，并不能直接加载到内存中然后倒序，否则会直接出现内存溢出的问题，对于这个问题，能做的就是老老实实的遍历，没有其他捷径，最多是入栈然后出栈直到遇到空格。然后我们说回上面的话题，为什么需要做实际的项目才能提高自身的水平，因为在理论上，或者说平时的实验中，我们是不会遇到说一个字符串100g然后去找最后一个单词的，但是当到了实际的项目中，任何的可能性都是存在的，比如我需要遍历一个mysql的文件，众所周知mysql的上限大小有500g，这个时候自然也是不能直接加载到内存中的，当然，mysql查找有二叉树并不需要说使用这个高复杂度的方法。言归正传，这里想说明的并不是说优秀的算法和差劲的算法之间的差距有多大，而是将理论进行实现有多重要。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/17/为什么需要通过做项目来提高代码的水平/" data-id="cjadl2o1b00003yjhhtp42910" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ktv里评分系统的算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/14/ktv里评分系统的算法/" class="article-date">
  <time datetime="2017-10-14T00:20:15.000Z" itemprop="datePublished">2017-10-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/14/ktv里评分系统的算法/">ktv里评分系统的算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>参考了东南大学学长的硕士毕业论文，没有按照论文顺序，顺序较为凌乱。</p>
<p>ktv的评分系统是如何判断一个人唱歌是否标准以及评分系统是否能准确的判定出一个人唱的有没有走调</p>
<p>评分系统判定过程一般是下面这样的：首先计算机通过屏幕输出一些有效提示，比如说声调高低，歌词之类，接着演唱者通过输入设备：麦克风，向计算机中输入声音信号，接着计算机通过一些列的评价算法评价演唱者的分数。</p>
<p>我们主要对评价算法进行分析。首先是这个演唱评价算法的核心是特征信息提取和演唱评价。特征提取是从演唱者的语音信号中提取能够反应演唱水平的特征参数，这就涉及到语音信号的采集和识别问题，因为语音信号采集的完整度以及识别的准确度都会在很大程度上影响最终的结果，这个部分我们会在接下来进行详细的介绍，之后我们讨论算法的另外一个主要部分，就是演唱评价，这个部分实际上是一个数学建模的问题，因为本质上计算机进行评价的过程就是一个数学评估的过程。</p>
<p>接下来我们对评分系统的特征提取进行详细的介绍。需要明确的一点是，特征提取是整个评价系统中重要的一部分。一方面，只有提取到的声音信息是有效的，合理的，能反应演唱者特征以及满足旋律规则的演唱特征，之后的评价才能对用户的真实水平进行有效的比较和判定，另一方面呢，只有对演唱者的特征进行有效的选取，才能在评分中准确的评价和量化。特征信息提取主要提取的信息是音调信息和节奏信息，换句话说就是采集演唱者的音高和音长，而音高由基音来决定，因此，准确的从演唱者的演唱过程中提取出基音可以有效的提高整个评分系统的性能。</p>
<p>接着稍微介绍下基音提取方法，这部分涉及较多的非本科知识，因此就只进行简单的介绍。基音提取技术主要有三种：时域处理法，频域处理法，以及时频域混合处理法。然后时域处理法主要是通过对波形进行分析来估计波形的周期和峰值，主要方法有：短时自相关法（ACF）、短时平均幅度差函数法（AMDF）以及并行处理法（PPROC），而频域处理法则是将语音信号映射到频域空间在进行分析直接获得基音频率，主要方法有：倒谱法、谐波峰值法、循环直方图法.而时频域混合则是综合了时域和频域的优点，主要方法是小波变换法。之后会在另一篇博客中对上述的多种算法进行介绍，可能咕咕咕，嗯？接下来我们继续讨论这个评分系统的算法。</p>
<p>然后关于演唱评分系统的特征提取算法，目前正在使用的已经较为成熟的特征提取算法已经成功的运用在哼唱检索系统中，而对比哼唱系统，实时演唱评分系统更加注重的是实时性，哼唱系统可以在声音完全录入完毕之后在对声音进行特征提取，但是演唱评分系统需要同步演唱者的输入信号进行实时处理并进行有效的反馈，也就是说，对于实时演唱系统，演唱者在演唱时候所演唱的内容是受到一定的约束的，比如音高，比如音长，而哼唱检索系统则没有这个问题，哼唱者只需要哼唱歌曲中的某一段就可以了，对演唱的速度、节奏的准确度并没有太大的严格，因此对比哼唱系统，实时演唱系统要求使用的特征算法拥有更低的算法复杂度以及能进行实时处理的要求。</p>
<p>特征信息提取算法的流程：</p>
<p>声音信号–&gt;声音录入–&gt;预处理–&gt;基音检测–&gt;特征获取–&gt;特征信息</p>
<p>我们对基音检测这个过程进行详细的介绍，之前的部分主要是对声音进行采集以及对声音进行相关的处理，这里我们介绍的方法是基于之前简单介绍的谐波峰值法，相对于常规的谐波峰值法，这里改进的目的主要有两个地方：首先是降低基音检测算法本身的复杂度，满足实时处理的需求，同时还需要保证基音检测的精度，因为如果因为降低了复杂度而丧失了精度的话其实是得不偿失的；其次是尽可能消除谐波对于基波选取时的干扰，能够更加准确的定位基音位置</p>
<p>简单介绍一下谐波峰值法，这是一种基于短时傅里叶变换的频域基音提取方法，通过STFT可以获得每一帧的语音信号的离散频谱，频谱峰值就是此帧信号所对应的基音。</p>
<p>上面说到了STFT把时域信号映射到频域进行基音的提取，通过STFT获得每一帧离散信号的离散频谱，理论上频谱的峰值点就是基音频率的所在点。</p>
<p>接着呢对上述得到的基音进行清浊音和谐波干扰，保证整个获取出来的基音序列是较为准确的基音频率，这也是当前需要进行更好的优化的部分，而除了基音部分之外，我们还需要从演唱者的声音中获取到静音帧以及半音等，在这之后，计算机就获得了一个半音序列，而这个半音序列就是之后音符划分和演唱评价的基础</p>
<p>接下来我们继续往下介绍，上面我们说到计算机对接受到的声音进行处理之后会得到一个半音序列，下面我们要对这个半音序列进行解析和评价。</p>
<p>首先介绍的是评分系统的模板部分，因为进行评价总需要一个依据来反映演唱的水准，这样的一个参考被称为评价模板</p>
<p>一个评价模板一般有这些信息：最小节拍时间，也就是每个曲子中最小节拍的持续时间；其次是调式偏移（==emmmmm），第三是句开始时间和结束时间，用来限定实时演唱每一句的评价范围；第四是字开始和长度，用来确定每一个字的开始时间和结束时间；第五是字半音值，也就是每个字的标准音高值；第六是连音信息，用来表示两个字之间需要连续演唱</p>
<p>介绍完评价模板我们介绍一下音符切分。上面说到通过处理之后我们获得了一个半音序列，而事实上，这个半音序列本质上就是演唱者演唱某一句的音高轮廓曲线，而通过评价模板，我们也获得了整个歌曲的标准音符信息，也就是说，接下来我们需要做的是事情就是从上述的音高轮廓中提取出相应的音符信息，然后通过与标准的音符信息进行对比，就可以得到演唱者的客观表现。而所谓的音符切分，就是将一个音高序列转化分割成离散的音符序列的过程，音符划分是真个算法的先导，同时也是整个算法的关键。一方面，从演唱行为上进行分析，演唱者演唱的内容实质上是一个个音符，如果能够从音高序列中区分出某一个音符的特征，就能获得和评价模板匹配的信息；另一方面，从评价模板信息中我们可以看到，如果能够勾勒出每一个音符的开始时间和结束时间，就可以与评价模板相对应，从而降低整个算法的复杂度，但是却不降低算法的精度。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/14/ktv里评分系统的算法/" data-id="cjadl2o2000043yjh3bvgjade" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-多人fps游戏的client端和server端如何实现互动" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/13/多人fps游戏的client端和server端如何实现互动/" class="article-date">
  <time datetime="2017-10-13T03:34:46.000Z" itemprop="datePublished">2017-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/13/多人fps游戏的client端和server端如何实现互动/">多人fps游戏的client端和server端如何实现互动</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>先假设这么一个场景：玩家a攻击了玩家b，然后一枪爆头，这个过程玩家a会向server端发送一个数据包，这个包就包含了上述的这些数据，接着server端收到之后会进行判定，比如说玩家b死亡等等，接着得到这些信息之后会将这个包广播给其他用户，告诉他们玩家a击杀了玩家b</p>
<p>首先讲一个关于服务器的概念就是什么叫做服务器的通信频率，tick rate 。事实上对于服务器来说并不是实时的向玩家通信来更新游戏状态的，首先最大的问题就是会导致很大的计算量，并且对于网络的带宽的要求也会很大，这样对于大部分玩家来说其实并不现实。因此服务器会采用一定的频率了来进行通信，举个例子如果一个游戏采用60hz的频率，就表示每1/60秒玩家的client端就会接收到一次新的信息，从这里我们可以发现的一个地方就是其实对于fps游戏，整个游戏过程其实并不是一个连续的过程而是一个离散的过程</p>
<p>然后接着说第二个关键词：高ping战士==。在上面的例子我们假设了其实不论玩家a还是玩家b的client端和server端之间的延迟都是无穷小的，但是这在现实中明显是不现实的事情，这里就需要说到一个叫做ping的概念，比如说假设玩家a的延迟是100ms，那么从发送数据包到重新接受结果的过程就是200ms，一个来回，然后我们这里假设通信频率是足够大的，不够大的情况之后在进行讨论。而对于这样的高ping战士==，比如他发送了一个向前移动的请求，从发出请求到服务器相应再到client端接收到这个请求，这整个过程中，如果client端没有任何的补偿策略，那么这0.2sclient端都不会出现任何的变化，换言之用户就会出现‘卡顿’的感觉</p>
<p>然后接着上面提到的补偿策略，因为其实对于一个fps游戏，当延迟较大的情况下，如果用户卡顿而导致一直无法进行操作这是不科学的，因此在很多的实际游戏：比如说csgo中，就有一种叫做延迟补偿策略的东西，首先第一种延迟补偿策略叫做客户预测法，那么什么叫做客户端预测法呢，简单来说就是在你等待数据包的200ms中，client端觉得你不能一直停留在原地吧，而且你也发送了移动的请求了，因此client端就擅自绘制出用户向前移动的画面，也就是说，如果client端可以事先预测出server端发送回来的信息，就可以事先绘制出来，然后等到收到server的信息之后在进行纠正，这就是fps游戏中有的会觉得’我是谁，我在那，我要做什么～‘</p>
<p>接着说第二种延迟补偿策略，刚才说的是针对client端的延迟补偿，除了上述的方法之外，针对client端的延迟补偿策略还有一种叫做插帧法。这种方法简单来说就是等到server的信息之后不马上绘制出来，而是一个逐渐的过程，这样可以有效的避免卡顿，但是如果用户并不是直线运行，比如绕墙，就会出现玩家穿墙的现象</p>
<p>说完了client端的延迟补偿策略，再来说说server端的延迟补偿策略。首先第一个就是对于玩家的延迟置之不理，这种方法常见在事件同时进行非常多的情况下，比如千人混战（某游戏），这种情况下浪费宝贵的server端的资源去补偿一个玩家的延迟很明显不科学，而这种延迟补偿策略，嗯？的缺点就是某些玩家的用户体验很差</p>
<p>接着说第二种，就是倒带法。采用倒带法的服务器会记录过去的一段时间，比如说500ms左右的内容，当某个延迟很大的玩家，比如100ms的玩家对server端发送数据包的时候，server端就会调用100ms前的状态进行判定，然后将结果广播给所有的玩家，这个策略最大的一个问题就是对于延迟较小的玩家也要体验较大的延迟</p>
<p>说完了延迟补偿策略来说说之前说到的低通信频率会造成的影响，首先第一个影响就是游戏的不连贯，因为比如游戏的更新的频率是10hz那么每0.1s才更新一次而正常人的反应时间是小于这个时间的，恩，没毛病，就能明显的感觉出整个游戏的不连贯了；其次就是瞬间击杀，什么意思呢，比如某些射速可以在一秒内连发多个子弹的==存在，假设玩家a开始射击的那个瞬间server端开始刷新，然后玩家a的两次射击都被服务器记录，然后这个过程中玩家a射击杀死了玩家b，而子在更新之前，也就是通信频率0.1s之内，玩家b并不会知道自己被射击的信息，也不知道自己被玩家a攻击了，而在0.1s之后，被玩家a连续攻击两次之后直接死亡，玩家b并不知道谁杀了自己，只知道被射击了两次，’我怎么死了，谁杀的我，他怎么杀的‘，</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/13/多人fps游戏的client端和server端如何实现互动/" data-id="cjadl2o2g00053yjht7og6kwr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/07/hello-world/" class="article-date">
  <time datetime="2017-10-07T13:55:31.600Z" itemprop="datePublished">2017-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/07/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/07/hello-world/" data-id="cjadl2o1i00013yjhxympff5c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/11/24/从零到一自己开发一个网站需要用到多少知识/">从零到一自己开发一个网站需要用到多少知识</a>
          </li>
        
          <li>
            <a href="/2017/11/02/数据库索引树的原理-B树/">数据库索引树的原理_B树</a>
          </li>
        
          <li>
            <a href="/2017/10/17/为什么需要通过做项目来提高代码的水平/">为什么需要通过做项目来提高代码的水平</a>
          </li>
        
          <li>
            <a href="/2017/10/14/ktv里评分系统的算法/">ktv里评分系统的算法</a>
          </li>
        
          <li>
            <a href="/2017/10/13/多人fps游戏的client端和server端如何实现互动/">多人fps游戏的client端和server端如何实现互动</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Crimson<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>